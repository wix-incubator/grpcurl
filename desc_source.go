package grpcurl

import (
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sync"

	"github.com/jhump/protoreflect/v2/grpcreflect"
	"github.com/jhump/protoreflect/v2/protoprint"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

// ErrReflectionNotSupported is returned by DescriptorSource operations that
// rely on interacting with the reflection service when the source does not
// actually expose the reflection service. When this occurs, an alternate source
// (like file descriptor sets) must be used.
var ErrReflectionNotSupported = errors.New("server does not support the reflection API")

// DescriptorSource is a source of protobuf descriptor information. It can be backed by a FileDescriptorSet
// proto (like a file generated by protoc) or a remote server that supports the reflection API.
type DescriptorSource interface {
	// ListServices returns a list of fully-qualified service names. It will be all services in a set of
	// descriptor files or the set of all services exposed by a gRPC server.
	ListServices() ([]string, error)
	// FindSymbol returns a descriptor for the given fully-qualified symbol name.
	FindSymbol(fullyQualifiedName string) (protoreflect.Descriptor, error)
	// AllExtensionsForType returns all known extension fields that extend the given message type name.
	AllExtensionsForType(typeName string) ([]protoreflect.FieldDescriptor, error)
}

// DescriptorSourceFromProtoSets creates a DescriptorSource that is backed by the named files, whose contents
// are encoded FileDescriptorSet protos.
func DescriptorSourceFromProtoSets(fileNames ...string) (DescriptorSource, error) {
	files := &descriptorpb.FileDescriptorSet{}
	for _, fileName := range fileNames {
		b, err := os.ReadFile(fileName)
		if err != nil {
			return nil, fmt.Errorf("could not load protoset file %q: %v", fileName, err)
		}
		var fs descriptorpb.FileDescriptorSet
		err = proto.Unmarshal(b, &fs)
		if err != nil {
			return nil, fmt.Errorf("could not parse contents of protoset file %q: %v", fileName, err)
		}
		files.File = append(files.File, fs.File...)
	}
	return DescriptorSourceFromFileDescriptorSet(files)
}

// DescriptorSourceFromProtoFiles creates a DescriptorSource that is backed by the named files,
// whose contents are Protocol Buffer source files. The given importPaths are used to locate
// any imported files.
func DescriptorSourceFromProtoFiles(importPaths []string, fileNames ...string) (DescriptorSource, error) {
	// For now, we'll use a simplified approach that requires the proto files to be compiled
	// In a full implementation, you would use a proto parser to parse .proto source files
	// and convert them to FileDescriptorProto instances, then use Registry.FromFileDescriptorSet

	// This is a placeholder implementation - in practice, you'd need to:
	// 1. Parse the .proto source files using a proto parser
	// 2. Convert them to FileDescriptorProto instances
	// 3. Create a FileDescriptorSet from those protos
	// 4. Use Registry.FromFileDescriptorSet to create a registry
	// 5. Extract the FileDescriptor instances from the registry

	return nil, fmt.Errorf("proto file parsing not yet implemented in v2 migration - requires proto parser integration")
}

// DescriptorSourceFromFileDescriptorSet creates a DescriptorSource that is backed by the FileDescriptorSet.
func DescriptorSourceFromFileDescriptorSet(files *descriptorpb.FileDescriptorSet) (DescriptorSource, error) {
	// This is a placeholder implementation for v2 migration
	// In a full implementation, you would need to convert FileDescriptorProto to FileDescriptor
	// This requires using the protodesc package or similar functionality
	return nil, fmt.Errorf("FileDescriptorSet parsing not yet fully implemented in v2 migration")
}

// resolveFileDescriptor is no longer needed in v2 as descriptor resolution is handled differently

// DescriptorSourceFromFileDescriptors creates a DescriptorSource that is backed by the given
// file descriptors
func DescriptorSourceFromFileDescriptors(files ...protoreflect.FileDescriptor) (DescriptorSource, error) {
	fileMap := make(map[string]protoreflect.FileDescriptor)
	for _, fd := range files {
		fileMap[fd.Path()] = fd
	}
	return &fileSource{files: fileMap}, nil
}

// addFile is no longer needed in v2 as file handling is different

type fileSource struct {
	files  map[string]protoreflect.FileDescriptor
	erInit sync.Once
}

func (fs *fileSource) ListServices() ([]string, error) {
	set := map[string]bool{}
	for _, fd := range fs.files {
		for i := 0; i < fd.Services().Len(); i++ {
			svc := fd.Services().Get(i)
			set[string(svc.FullName())] = true
		}
	}
	sl := make([]string, 0, len(set))
	for svc := range set {
		sl = append(sl, svc)
	}
	return sl, nil
}

// GetAllFiles returns all of the underlying file descriptors. This is
// more thorough and more efficient than the fallback strategy used by
// the GetAllFiles package method, for enumerating all files from a
// descriptor source.
func (fs *fileSource) GetAllFiles() ([]protoreflect.FileDescriptor, error) {
	files := make([]protoreflect.FileDescriptor, len(fs.files))
	i := 0
	for _, fd := range fs.files {
		files[i] = fd
		i++
	}
	return files, nil
}

func (fs *fileSource) FindSymbol(fullyQualifiedName string) (protoreflect.Descriptor, error) {
	// For v2, we need to search through the files manually
	// This is a simplified implementation
	for _, fd := range fs.files {
		// Search in messages
		for i := 0; i < fd.Messages().Len(); i++ {
			msg := fd.Messages().Get(i)
			if string(msg.FullName()) == fullyQualifiedName {
				return msg, nil
			}
		}
		// Search in services
		for i := 0; i < fd.Services().Len(); i++ {
			svc := fd.Services().Get(i)
			if string(svc.FullName()) == fullyQualifiedName {
				return svc, nil
			}
		}
		// Search in enums
		for i := 0; i < fd.Enums().Len(); i++ {
			enum := fd.Enums().Get(i)
			if string(enum.FullName()) == fullyQualifiedName {
				return enum, nil
			}
		}
	}
	return nil, notFound("Symbol", fullyQualifiedName)
}

func (fs *fileSource) AllExtensionsForType(typeName string) ([]protoreflect.FieldDescriptor, error) {
	// For v2, extension handling is different
	// This is a placeholder implementation
	return nil, fmt.Errorf("extension handling not yet implemented in v2 migration")
}

// DescriptorSourceFromServer creates a DescriptorSource that uses the given gRPC reflection client
// to interrogate a server for descriptor information. If the server does not support the reflection
// API then the various DescriptorSource methods will return ErrReflectionNotSupported
func DescriptorSourceFromServer(_ context.Context, refClient *grpcreflect.Client) DescriptorSource {
	return serverSource{client: refClient}
}

type serverSource struct {
	client *grpcreflect.Client
}

func (ss serverSource) ListServices() ([]string, error) {
	// For v2, we need to convert the service descriptors to strings
	svcDescs, err := ss.client.ListServices()
	if err != nil {
		return nil, reflectionSupport(err)
	}
	svcs := make([]string, 0, len(svcDescs))
	for _, svc := range svcDescs {
		svcs = append(svcs, string(svc))
	}
	return svcs, nil
}

func (ss serverSource) FindSymbol(fullyQualifiedName string) (protoreflect.Descriptor, error) {
	// Use the grpcreflect client to find the symbol
	desc, err := ss.client.FileContainingSymbol(protoreflect.FullName(fullyQualifiedName))
	if err != nil {
		return nil, reflectionSupport(err)
	}

	// Find the specific symbol within the file descriptor
	return findSymbolInFile(desc, fullyQualifiedName)
}

func (ss serverSource) AllExtensionsForType(typeName string) ([]protoreflect.FieldDescriptor, error) {
	// Use the grpcreflect client to get extensions for the type
	extNums, err := ss.client.AllExtensionNumbersForType(protoreflect.FullName(typeName))
	if err != nil {
		return nil, reflectionSupport(err)
	}

	var extensions []protoreflect.FieldDescriptor
	for _, extNum := range extNums {
		// Get the file containing the extension
		fd, err := ss.client.FileContainingExtension(protoreflect.FullName(typeName), extNum)
		if err != nil {
			continue // Skip if we can't find the extension
		}

		// Find the extension field in the file
		// This is a simplified approach - in practice, you'd need to search through the file
		// to find the extension field with the matching number
		_ = fd // TODO: Implement proper extension field lookup
	}

	return extensions, nil
}

// findSymbolInFile searches for a symbol within a file descriptor
func findSymbolInFile(fd protoreflect.FileDescriptor, symbolName string) (protoreflect.Descriptor, error) {
	targetName := protoreflect.FullName(symbolName)

	// Search in messages
	for i := 0; i < fd.Messages().Len(); i++ {
		msg := fd.Messages().Get(i)
		if msg.FullName() == targetName {
			return msg, nil
		}
		// Search in nested messages
		if desc := findSymbolInMessage(msg, targetName); desc != nil {
			return desc, nil
		}
	}

	// Search in services
	for i := 0; i < fd.Services().Len(); i++ {
		svc := fd.Services().Get(i)
		if svc.FullName() == targetName {
			return svc, nil
		}
		// Search in methods
		for j := 0; j < svc.Methods().Len(); j++ {
			method := svc.Methods().Get(j)
			if method.FullName() == targetName {
				return method, nil
			}
		}
	}

	// Search in enums
	for i := 0; i < fd.Enums().Len(); i++ {
		enum := fd.Enums().Get(i)
		if enum.FullName() == targetName {
			return enum, nil
		}
		// Search in enum values
		for j := 0; j < enum.Values().Len(); j++ {
			val := enum.Values().Get(j)
			if val.FullName() == targetName {
				return val, nil
			}
		}
	}

	return nil, fmt.Errorf("symbol %q not found", symbolName)
}

// findSymbolInMessage recursively searches for a symbol within a message and its nested elements
func findSymbolInMessage(msg protoreflect.MessageDescriptor, targetName protoreflect.FullName) protoreflect.Descriptor {
	// Search in nested messages
	for i := 0; i < msg.Messages().Len(); i++ {
		nested := msg.Messages().Get(i)
		if nested.FullName() == targetName {
			return nested
		}
		if desc := findSymbolInMessage(nested, targetName); desc != nil {
			return desc
		}
	}

	// Search in nested enums
	for i := 0; i < msg.Enums().Len(); i++ {
		enum := msg.Enums().Get(i)
		if enum.FullName() == targetName {
			return enum
		}
		for j := 0; j < enum.Values().Len(); j++ {
			val := enum.Values().Get(j)
			if val.FullName() == targetName {
				return val
			}
		}
	}

	return nil
}

func reflectionSupport(err error) error {
	if err == nil {
		return nil
	}
	if stat, ok := status.FromError(err); ok && stat.Code() == codes.Unimplemented {
		return ErrReflectionNotSupported
	}
	return err
}

// WriteProtoset will use the given descriptor source to resolve all of the given
// symbols and write a proto file descriptor set with their definitions to the
// given output. The output will include descriptors for all files in which the
// symbols are defined as well as their transitive dependencies.
func WriteProtoset(out io.Writer, descSource DescriptorSource, symbols ...string) error {
	filenames, fds, err := getFileDescriptors(symbols, descSource)
	if err != nil {
		return err
	}
	// now expand that to include transitive dependencies in topologically sorted
	// order (such that file always appears after its dependencies)
	expandedFiles := make(map[string]struct{}, len(fds))
	allFilesSlice := make([]*descriptorpb.FileDescriptorProto, 0, len(fds))
	for _, filename := range filenames {
		allFilesSlice = addFilesToSet(allFilesSlice, expandedFiles, fds[filename])
	}
	// now we can serialize to file
	b, err := proto.Marshal(&descriptorpb.FileDescriptorSet{File: allFilesSlice})
	if err != nil {
		return fmt.Errorf("failed to serialize file descriptor set: %v", err)
	}
	if _, err := out.Write(b); err != nil {
		return fmt.Errorf("failed to write file descriptor set: %v", err)
	}
	return nil
}

func addFilesToSet(allFiles []*descriptorpb.FileDescriptorProto, expanded map[string]struct{}, fd protoreflect.FileDescriptor) []*descriptorpb.FileDescriptorProto {
	if _, ok := expanded[fd.Path()]; ok {
		// already seen this one
		return allFiles
	}
	expanded[fd.Path()] = struct{}{}
	// add all dependencies first
	for i := 0; i < fd.Imports().Len(); i++ {
		allFiles = addFilesToSet(allFiles, expanded, fd.Imports().Get(i))
	}
	// For v2, we need to convert protoreflect.FileDescriptor to FileDescriptorProto
	// This is a placeholder implementation
	return allFiles
}

// WriteProtoFiles will use the given descriptor source to resolve all the given
// symbols and write proto files with their definitions to the given output directory.
func WriteProtoFiles(outProtoDirPath string, descSource DescriptorSource, symbols ...string) error {
	filenames, fds, err := getFileDescriptors(symbols, descSource)
	if err != nil {
		return err
	}
	// now expand that to include transitive dependencies in topologically sorted
	// order (such that file always appears after its dependencies)
	expandedFiles := make(map[string]struct{}, len(fds))
	allFileDescriptors := make([]protoreflect.FileDescriptor, 0, len(fds))
	for _, filename := range filenames {
		allFileDescriptors = addFilesToFileDescriptorList(allFileDescriptors, expandedFiles, fds[filename])
	}
	pr := protoprint.Printer{}
	// now we can serialize to files
	for i := range allFileDescriptors {
		if err := writeProtoFile(outProtoDirPath, allFileDescriptors[i], &pr); err != nil {
			return err
		}
	}
	return nil
}

func writeProtoFile(outProtoDirPath string, fd protoreflect.FileDescriptor, pr *protoprint.Printer) error {
	outFile := filepath.Join(outProtoDirPath, fd.Path())
	outDir := filepath.Dir(outFile)
	if err := os.MkdirAll(outDir, 0777); err != nil {
		return fmt.Errorf("failed to create directory %q: %w", outDir, err)
	}

	f, err := os.Create(outFile)
	if err != nil {
		return fmt.Errorf("failed to create proto file %q: %w", outFile, err)
	}
	defer f.Close()
	if err := pr.PrintProtoFile(fd, f); err != nil {
		return fmt.Errorf("failed to write proto file %q: %w", outFile, err)
	}
	return nil
}

func getFileDescriptors(symbols []string, descSource DescriptorSource) ([]string, map[string]protoreflect.FileDescriptor, error) {
	// compute set of file descriptors
	filenames := make([]string, 0, len(symbols))
	fds := make(map[string]protoreflect.FileDescriptor, len(symbols))
	for _, sym := range symbols {
		d, err := descSource.FindSymbol(sym)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to find descriptor for %q: %v", sym, err)
		}
		fd := d.ParentFile()
		if _, ok := fds[fd.Path()]; !ok {
			fds[fd.Path()] = fd
			filenames = append(filenames, fd.Path())
		}
	}
	return filenames, fds, nil
}

func addFilesToFileDescriptorList(allFiles []protoreflect.FileDescriptor, expanded map[string]struct{}, fd protoreflect.FileDescriptor) []protoreflect.FileDescriptor {
	if _, ok := expanded[fd.Path()]; ok {
		// already seen this one
		return allFiles
	}
	expanded[fd.Path()] = struct{}{}
	// add all dependencies first
	for i := 0; i < fd.Imports().Len(); i++ {
		allFiles = addFilesToFileDescriptorList(allFiles, expanded, fd.Imports().Get(i))
	}
	return append(allFiles, fd)
}
